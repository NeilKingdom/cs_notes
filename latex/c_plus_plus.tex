\documentclass{article}

\usepackage{titling}
\usepackage{geometry}
\usepackage{fontspec}
\usepackage{color}
\usepackage{xcolor}
\usepackage{tcolorbox}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{tabularx}
\usepackage{minted}
\usepackage[skip=11pt]{parskip}

\definecolor{bg}{RGB}{22,43,58}

\hypersetup{
    colorlinks=true,
    urlcolor=blue
}

\tcbuselibrary{listings, minted, skins}
\tcbset{listing engine=minted}

% C++ codeblocks
\newtcblisting{cpplst}{%
   listing only,
   minted language=cpp,
   minted style=monokai,
   colback=bg,
   enhanced,
   frame hidden,
   minted options={%
      tabsize=4,
      breaklines,
      autogobble
   }
}

\hypersetup{%
   colorlinks=true,
   linktoc=all,
   linkcolor=gray,
}

\setmainfont{LiberationSans}
\geometry{%
  margin=1in
}

\fancyhf{}
\renewcommand{\headrulewidth}{0pt}
\fancyfoot[R]{\thepage}
\pagestyle{fancy}
\fancypagestyle{plain}{\pagestyle{fancy}}

\renewcommand\maketitlehooka{\null\mbox{}\vfill}
\renewcommand\maketitlehookd{\vfill\null}

\title{The C++ Programming Language}
\author{Neil Kingdom}

\begin{document}

\begin{titlingpage}

\maketitle

\end{titlingpage}

\newpage

\tableofcontents

\newpage

\section{Abstract}

This document covers the C++ programming language in as much detail as possible. Please note that C++ is an
advanced programming language. In fact, I’d highly recommend that you learn two languages prior to learning
C++ - preferably an OOP language like Java and a procedural language like C. If you are insistent on learning
C++ as your first language, I suggest you check out Cherno's playlist on YouTube. I do have a soft spot for
C++ as a language, but perhaps its biggest flaw is that it has too many features to its detriment. There are so
many ways to go about solving a problem in C++, that it tends to lead to analysis paralysis. It is also a very
syntactically rich language and uses a lot of special characters for semantic purposes, which often makes it
difficult to read. Having some prior experience with other languages will certainly come in handy when trying
to overcome these barriers.

\section{Introduction}

C++ was created in 1979 by a gentleman named Bjarne Stroustrup. Stroustrup was born in 1950 and worked for
Bell Laboratories. Denis Richie and Ken Thompson also worked for Bell labs and invented the C programming
language. Stroustrup likely felt that C was lacking and sought to expand it. C++ was originally called "C with
Classes". Its original goal was to stay the same as C, but simply add OOP concepts like classes, methods,
inheritance, and polymorphism. C++ was not readily available for public use until about 1985. In the present,
most people have shifted over from C to C++. This is due to the fact that C++ can do everything C can do using
essentially the exact same syntax, while also offering the flexibility to use more modern features of the
language if needed. C++ is a very general purpose programming language that can create a wide range of
applications. Examples might be game engines, operating systems, web backends, etc. With an idea of what C++
actually is, we can begin to look at some of the differences between it, and C.

\section{The Myth of Backwards Compatability With C}

You will oft hear it stated that C is simply irrelevant due to the fact that C++ is backwards compatible with
it! This is simply untrue, however. Furthermore, C cannot be called a "subset" of C++ either - they are two
distinct languages that have, and continue to, deviate more and more over time. I bring this up because,
although you can write programs that would run in both a C compiler and a C++ compiler, this is not indicative
of backwards compatibility, as so many believe. There are instances where we may write identical lines of code
in both C and C++ which operate in a completely different manner than one another.

\section{Basic I/O}

Let's begin with printing text to the console. Outputting text in C++ looks something like the following:

\begin{cpplst}
std::cout << "text";
\end{cpplst}

std is a C++ namespace and the two colons :: are used to denote scope. std is C++'s standard library
(libstdc++) namespace, meaning that it is the namespace which encapsulates the definitions of entities/symbols
defined in the standard library. cout and cin are symbols defined in iostream, which is a header file (C++
headers don't need to have a .h extension). We can include this header file using, you guessed it, the
\#include directive e.g. \#include <iostream>. cout stands for character output stream. Its type is ostream
(output stream) which is a typedef for basic\_ostream, which is a C++ class. If you’re familiar with Linux,
you will recognize this << as being the redirection operator. std::cout << "text"; can be read as 'redirect
the string "text" to the character output stream (stdout)'. Without the inclusion of the std namespace, C++
would search what is called the global namespace, which includes anything that is defined globally. The global
namespace can also be referenced by prepending the scope operator without a name e.g. ::foo would look for foo
in the global namespace. Though the global namespace is not explicitly defined, it is not an unnamed namespace.

When it comes to std::cout, we can use std::endl (end line) which will do two things: insert a newline feed,
as well as flush the stream. It is acceptable to just manually add a newline character to the end of your
string, however, endl is generally considered cleaner e.g.

\begin{cpplst}
std::cout << "Hello world!" << std::endl;
\end{cpplst}

Notice how we redirect multiple things to std::cout. This is akin to concatenating a string. For example, we
can do something like:

\begin{cpplst}
std::cout << "Number is: " << num << std::endl;
\end{cpplst}

This will output the text "Number is: " followed by the value of num as a string.

In order to read from stdin, we can do something like:

\begin{cpplst}
std::cin >> var;
\end{cpplst}

stdin will await the enter key and will then redirect the contents of the stdin buffer to var in this case.
Two things to note here: 1) Notice that the redirection operator points towards the variable, whereas, with
std::cout, the redirection operator pointed towards the stream. This is pretty intuitive but easily forgotten.
2) std::cin does some special trickery to avoid runtime errors when accepting user input. Programmers need to
be cautious of this, because std::cin might not return what the user actually entered. The way std::cin works
when converting user input to an integer type is to extract all digits up until the first non-digit character.
For example, if redirecting stdin to an int, and the user enters something like 12a34b56, std::cin will
extract 12 and discard the rest. If the user enters no digits e.g. abcdef, std::cin returns 0. A similar
concept applies to floats, with the difference being that std::cin will accept a period as being the decimal
point for the float. C++ can recognize that certain types will always fail at compile time. For instance,
attempting to redirect stdin to an object will fail at compile time (there are exceptions to this if we use
operator overloading, which we will discuss later).

\section{std::string, std::vector, and std::array}

Though C++ supports C-style strings and C-style arrays, it is considered more idiomatic to use std::string,
std::array, and std::vector when defining strings, arrays, and dynamic arrays, respectively. There are benefits
to using these since C++ collections are polymorphic and share a lot of the same behaviours. Whichever you
decide to use, just be consistent in your codebase, since swapping between C-style strings or arrays and C++
strings or arrays can get real messy real fast.

If you're familiar with other OOP languages, the std::string, std::vector, and std::array classes should feel
pretty familiar to you. std::string is actually a typedef for basic\_string<char>. Since basic\_string accepts
a generic type (we'll discuss this more later in the document), we can have other kinds of strings that behave
exactly the same but with different character encoding widths that vary depending on platform. For example
std::wstring is a typedef for basic\_string<wchar\_t> which is used for strings that need to support unicode.
We also have u8string, u16string, and u32string. As is the case for most collections in C++ (including
std::array and std::vector), there is support for iterators via the begin() and end() member functions.
Likewise, rbegin() and rend() return a reverse iterator. We have modifier member functions such as clear(),
insert(), push\_back(), pop\_back(), append(), replace(), copy(), resize(), etc. and also methods for
searching substrings like find(), rfind(), find\_first\_of(), find\_last\_of(), etc. C++11 even added support
for converting to numerics using the familiar sto* functions e.g. stoi(), stof, stol. C++ strings can be
indexed akin to C-style strings using the index operator to capture a character at the provided offset, or
alternatively you can use the at() function which does the same thing. std::basic\_string has many, many
constructor overloads that I won’t cover here, but perhaps the most notable overload is the one that allows us
to convert from a C-style string to a C++ string. Here’s an example:

\begin{cpplst}
const char *cstr = "foo";
auto cppstr = std::string(cstr);
\end{cpplst}

We can also convert from a C++ string into a C-style string using the c\_str() member function. As you may be
able to tell, C++ strings give us a lot of powerful operations and capabilities.

std::array is meant to be something of a replacement for C-style arrays. Personally, I don’t tend to lean
towards using std::array, since I find C-style arrays to be a bit simpler, however, std::array is beneficial
if you know that you’ll be repeating operations like reverse, swap, or copy a lot. std::array by itself
actually does not provide that many member functions (only fill() which is equivallent to memset and swap()
for swapping contents with another array). This is where the algorithm library comes in handy in extending the
capabilities of std::array by adding things like sort(), max(), min(), and a dozen others. std::array is, once
again, a templated class which accepts the type that will be used for the elements of the array, as well as
the size of the array, since arrays must be statically sized at compile time in C++, same as in C. Creating an
array in C++ might look something like:

\begin{cpplst}
auto arr = std::array<float, 3>{ 1.0f, 2.5f, 3.0f };
\end{cpplst}

Note that in C++, objects which are able to be assigned initializer lists can instead use the above syntax
where the initializer list directly proceeds the type. Here are other valid ways to initialize a std::array:

\begin{cpplst}
auto arr = std::array<float, 3>({ 1.0f, 2.5, 3.0f }); // Initializer list as an argument
std::array<float, 3> arr = { 1.0f, 2.5f, 3.0f }; // C-style assignment
std::array arr{ 1.0f, 2.5f, 3.0f }; // Generic type T is inferred
std::array<float, 3> arr{}; // Capacity is 3 but array is initially empty
\end{cpplst}

std::vector is used for dynamically sized arrays, but is syntactically very similar to std::array. Unlike
std::array, std::vector has a resize() function, as well as a couple more member functions like pop\_back(),
push\_back(), erase(), insert(), etc.

\section{C++ Header Files}

The standard C++ library has copies of all of the standard C library headers. An exhaustive list can be found
\href{https://en.cppreference.com/w/cpp/header}{here}. You'll notice that some headers in C++ begin with the
prefix 'c'. This means that it is a compatibility header and is identical to its C counterpart. For example,
\#include <assert.h> is equivallent to \#include <cassert> as they contain the same contents. I recommend
always using the C++ compatibility counterpart over the libc header. Other headers such as stdio.h and
threads.h are replaced with completely separate implementations, but that are usually functionally similar e.g.
iostream is similar to stdio.h and thread is similar to pthread.h. Common stand-alone headers which don't have
C equivallents include fstream for file manipulation, iterator (for iterators), chrono for time (there is a
compatibility header for time.h called ctime, but I recommend using chrono instead), algorithm for
datastructures and sorting/comparisons, memory for smart pointers, etc.

As I mentioned earlier, C++ header files can optionally omit the .h extension. They also happen to be able to
accept both the .h extension, as well as the .hpp extension. Source files do not abide by the same rules, as
they must always have the .cpp extension.

\section{Function Nuances}

C++ has a couple new features when it comes to functions which C did not have, so I'd like to highlight some
of them in the following subsections.

\subsection{Default Arguments}

The first addition to C++ functions that I'll cover is default arguments. I really like this feature in C++.
Essentially if you have a function that has a particular parameter which will have the same value passed in
most of the time, you can set that argument to have a default value so that if no argument is passed when
calling the function, it presumes the default value. This is quite intuitive, we just set the parameter = to
the value we want e.g.

\begin{cpplst}
void foo(int param1, int param2 = 5)
{
    // Do something
}
\end{cpplst}

Now if we call foo() with only one argument e.g. foo(3), param2 will be 5, but if we call foo() with both
arguments, param2 will use the one we provided. Similar to var args (variable arguments), default arguments
need to be placed last in the set of parameters. i.e. you cannot have a default parameter followed by a
non-default parameter.

\subsection{Function Overloading}

The other addition to C++ which C did not have is function overloading. Obviously in C, we could sort of
recreate the same principle by setting the parameters to void pointers and then casting the pointer to whichever
type was necessary, as well as using var args, however, this is not actually the same as function overloading.
If the overloaded functions signature differs by either having a different number of parameters or changing at
least one of the datatypes of at least one parameter (can be achieved by rearranging the order of datatypes in
the parameter list as well) then we can create a separate definition and overload that function.

\begin{cpplst}
void foo();         // No parameter version
void foo(int a);    // Parameterized version using int
void foo(float a);  // Parameterized version using float
\end{cpplst}

\section{Classes and Objects}

This section of the document is where we are going to begin getting a bit more in-depth on the OOP aspects of
C++. First, let us look into how C++ uses header files and source files perhaps a bit differently than in C.
Though not a strict requirement of the language, the most common practice is to define classes and their
respective member function declarations/signatures within a header file, and then define these member functions
within the source file. I personally try to avoid mixing header files intended for classes with other general
purpose header files. This is mostly because I like to name my header files containing class declarations after
the class, similar to Java. This is not, however, a requirement of the language in C++ (unlike Java). I will
also give the source file with class definitions the same name. I find this just makes the codebase a little
easier to read and maintain. You do have a lot of flexibility outside of this though. For instance, we don't
actually need header files at all. You could declare a class within a source file and also declare all of its
member functions in-place, without separating them into declaration and definition. With that said, this is
my document, so I’m going to teach things in the manner that I do them. Here is an example of a header file
for an Animal class:

\begin{cpplst}
class Animal
{
public:
    // Constructor/destructor
    Animal(std::string name, bool has_fur, double speed);
    ~Animal();

    // Member functions
    std::string get_name();
    bool get_has_fur();
    double get_speed();

private:
    // Member variables
    std::string m_name;
    bool m_has_fur;
    double m_speed;
};
\end{cpplst}

This class might reside in a file called animal.h (although it could just as easily reside in a source file as
well). C++ allows us to define public and private segments within both classes and structs. The private
specifier is assumed if no specifier is given (something we will discuss more shortly), however, I personally
think it's still good to explicitely declare your variables as being private because it takes no time and
improves readability. We might use private for variables or methods which should only be accessible to the
class itself, as well as subclasses/child classes, whereas public can be accessed from any file or class. In
animal.cpp, we would then define the actual code block/body for each of the declared functions in animal.h.

\begin{cpplst}
#include "animal.h"

Animal::Animal(std::string name, bool has_fur, double speed)
{
    m_name = name;
    m_has_fur = has_fur;
    m_speed = speed;
}

Animal::~Animal()
{}

std::string Animal::get_name()
{
    return m_name;
}

void Animal::get_has_fur()
{
    return m_has_fur;
}

double Animal::get_speed)
{
    return m_speed;
}
\end{cpplst}

Note how each method definition in the animal.cpp file starts with the Animal namespace even though we never
explicitly declared an Animal namespace. This is because every class in C++ creates its own namespace to avoid
namespace collisions for functions that share the same name across different classes. Even though we include the
animal.h header file, the default behavior of the compiler when it comes across a function definition is to
search for its definition in the global namespace. This is a similar issue to when we tried accessing cout and
cin without the std namespace.

Let's discuss instantiating the Animal class. There are technically 3 ways to instantiate an object in C++,
though the third has a bit of a catch. Let's look at an example of each:

\begin{cpplst}
#include <iostream>
#include “animal.h”

int main()
{
    Animal cat("cat", true, 1.2); // Method 1
    Animal dog = Animal("dog", true, 2.3); // Method 2
    Animal bird = new Animal("bird", false, 6.8); // Method 3
    delete bird;
}
\end{cpplst}

The first method is something of a shorthand because it avoids the unnecessary repetition of method 2, where
we first declare the type as Animal and also assign dog the instance returned by the Animal constructor. Method
1 does both the declaration and assignment in one step. Note though that Method 1 has a slight variation when
using the default constructor. For example, Foo foo(); will fail at compile time because the compiler will
think that this is a function declaration. For the default constructor in particular, the correct syntax is to
just omit the brackets like so: Foo foo; In the case of cat, we are using a parameterized constructor, so the
brackets are required. The first and second method share something in common which the third does not share,
and that is that the first and second methods allocate the instance of Animal on the stack, whereas the new
keyword used in method 3 creates a heap-allocated instance. See the next section for an explanation of the new
and delete keywords.

\section{The new and delete Keywords}

Unlike most modern OOP languages, C++ does not have a garbage collector. In C, we used malloc() and free() to
invoke the allocator and deallocator respectively. Instead of malloc() and free, C++ uses new and delete. The
new keyword, when used for creating an instance of an object, will first allocate the appropriate amount of
memory on the heap required for storing the object. Once the memory is allocated, the constructor is then
invoked. Likewise the delete keyword will first invoke the object's destructor, and then call the default
deallocator to free the object. Although malloc() and free() are available in C++, it is generally advisable
that you use new and delete for anything that needs to be heap-allocated. This is especially true for objects,
since they may do important cleanup within the destructor.

\section{Entity Qualifiers}

static, const, and auto make a return in C++, however, with some slight modifications in comparison to C. As
there are subtle differences with C++, it would be good for you to review them.

\subsection{static}

The static keyword has not really changed since C. It still indicates to the compiler that the function or
variable which proceeds will only be visible within the current translation unit. Of course, this means that
we can still get away with things like defining the same function name twice, although this is still not
recommended, as there are much better ways in C++ to do this (e.g., function overloading or namespaces). When
a member function is declared static within a struct or class, it essentially makes the function no longer a
member function of that class. In fact, a member function declared with the static keyword works exactly the
same whether it is declared inside or outside of the class body. This is because all instances of a class
have access to the same static member i.e., it is not reproduced for each instance of the class. The advantage
to declaring a static member within a class is that we can access it using the class' namespace e.g.,
Foo::staticMember; which can increase readability.

\subsection{const}

As you probably know, const discourages modifications to a variable's memory or value. There happen to be
ways to get around this, however, using pointers. Because it is fairly easy to change a const value, it is
typically considered more of a promise, rather than an absolutely sure-fire way of protecting the data from
being modified. The const keyword takes on a different meaning when qualifying a member function. As you can
see in the code snippet below, placing const after the function signature prevents modifiication of a class'
member variables. This only applies to member functions and not static or global functions, for obvious
reasons.

\begin{cpplst}
Class Foo {
private:
    int i;
public:
    void mutate_i() const {
        this->i = 4; // Cannot assign to non-static data member within const member function 'mutate_i'
    }
};

int main() {
    Foo f;
    f.mutate_i();
}
\end{cpplst}

\subsection{auto}

In C, auto was the implicit default for all stack-allocated variables. There was essentially never any reason
to actually use it. I suppose this is why C++ decided to repurpose it for something entirely different. In
C++, auto now tells the compiler to infer the type of a variable. Note that this is still type-safe since the
type is inferred from the rvalue of the expression. Once inferred, its type cannot be dynamically altered unlike
an interpreted language such as JavaScript or Python. For example, we cannot do:

\begin{cpplst}
auto a;
a = 5;
\end{cpplst}

Rather, we must do auto a = 5;. a's type will be determined by the compiler by looking at the rvalue (in this
case, 5), which it knows is an int, and therefore, will make a of type int.

\section{Pointers vs References}

If you've programmed in C, you are surely by now painly aware of how pointers work. For those younger folk who
are blissfully unaware of pointer voodoo magic, I won't be catching you up to speed, but if I can attempt to
summarize briefly, pointers are simply variables which store memory addresses to other variables, akin to a
lookup table. C++ attempts to do away with pointers for a couple good reasons. Perhaps the most catastrophic
aspect of pointers is the fact that we can have two pointers to the same memory location. This can lead to
chaos if not properly managed, since we can have two writers attempting to write over each other, which leads
to data clobbering and confusion. The root of this issue is why so many languages have transitioned towards
the notion of object ownership and move semantics. For compatibilities sake, C++ still allows us to utilize
pointers if necessary, but there is almost no need to use them unless you're extending pre-existing code
written in C. If you'll recall, we differentiate between pointers and primitives by placing an asterisk between
the variable's type and its name. We use the ampersand to retrieve the address of a variable. Furthermore, we
can assign NULL to a pointer, which is typically a good idea if the pointer has not yet been initialized, so
that we don't attempt to dereference some random address (since stack-allocated pointers will contain a
garbage value by default).

\begin{cpplst}
    int main()
    {
        int x = 10;
        int *px = nullptr;

        px = &x;
        std::cout << "Value of x is " << *px;
    }
\end{cpplst}

So what are the benefits of using references over pointers? Well, to begin, references must be assigned a
value when they are initialized/declared. Furthermore, references cannot be assigned a value of NULL or
nullptr. Another related fact is that references cannot be reassigned to a different value after they are
initialized. This is effectively equivallent to making a const pointer such that the underlying memory of the
pointer cannot be mutated (though the value of the variable being pointed to may change). The pragmatic
purpose for all of these differences is that we avoid trouble with references such as accidentally
dereferencing a NULL pointer or having the underlying memory address of the reference be updated without our
knowing.

References differ quite a bit from pointers semantically as well. In my opinion, the creators of C++ chose
poorly when they decided to repurpose the ampersand to denote a variable as a reference. This is highly
contextual since the ampersand can simultaneously represent an address depending on where it is used. Similar
to pointers, placing the ampersand between the variable's type and its name indicates that the variable is a
reference, but used anywhere else and ampersand almost always indicates an address. Fortunately, however,
references no longer need to be explicitly dereferenced, nor do you need to explicitly use the address
operator when initializing a reference like you would for pointers. Here is the same code snippet as before,
but using a reference rather than a pointer:

\begin{cpplst}
    int main()
    {
        int x = 10;
        int &rx = x;

        std::cout << "Value of x is " << rx;
    }
\end{cpplst}

As a reminder (and this applies to pointers as well), it is generally wise to make your parameters references
if you're passing in a struct which is greater in size than your computer's word length. For example, on a
64-bit machine, a pointer or reference will occupy 4 bytes, so if your struct is greater than 4 bytes in size
(which is nearly always the case) then it will save compute cost to setup the stack frame with a reference to
that data rather than passing a copy of the entire structure over the memory bus.

On a final note, newcomers may become confused about converting between pointers and references. Once you
have a firm grasp on the basics this isn't actually all that difficult to do, but I too struggled with this
initially, so for those of you who are confused, you have my sympathy. Understanding that references implicitly
prepend your variables with the address operator during assignment and implicitly dereference themselves when
being read is the key to dealing with these sorts of issues. Here is  a quick snippet to help visualize this:

\begin{cpplst}
    int main()
    {
        int x = 10;
        int *px = &x;
        int &rx = *px; // Here we effectively are doing &(*px), which cancels out to rx = px
        *px = rx; // Implicit dereference of rx to get the value 10
    }
\end{cpplst}

\section{NULL vs nullptr}

In the previous section, I utilized the nullptr keyword, which may or may not have been a surprise to you
depending upon your background. Even though C++ allows us to utilize the NULL macro, in the same vain as
references vs pointers, it is advised that you utilize the nullptr keyword over the NULL macro. The most
compelling reason for this is that nullptr is directly embedded into the language, meaning that it is platform
agnostic, whereas NULL actually gets included from the standard library as a macro and its definition may
vary depending upon the platform. Considering NULL usually just resolves to the integer 0, this lets us do
all sorts of odd things such as type conversions and casting, which is generally not the programmer's intent.
nullptr can only be assigned to poiner types in C++, and it cannot be cast or disambiguated. Another common
example that is used to disuade against the use of NULL is the ambiguous function call example. Considering
C++ introduces function overloading, imagine a scenario where we have two functions - one which accepts an
integer as its sole parameter, and another which accepts a char pointer. Now imagine we invoke this function
and pass in a value of NULL. Which function ought the compiler invoke under this circumstance since both
signatures can reasonably accept the argument?

\begin{cpplst}
    void foo(int x)
    {
        // ...
    }

    void foo(char *c)
    {
        // ...
    }

    int main()
    {
        foo(NULL); // Ambiguous function call
    }
\end{cpplst}

\section{Namespaces in Detail}

You may find as we write code in C++, that it becomes increasingly tiresome to explicitly state that our
strings or vectors are from the standard C++ namespace. We can remedy this to some degree by telling C++ to
search a particular namespace when it cannot find the definition of the function in the global namespace. By
using the "using" directive, we can specify a namespace for C++ to search if namespace is explicitly provided.
You will likely often see people add the line "using namespace std;" This tells C++ to search the standard
namespace which means that we no longer have to type std::string, std::vector<datatype T>, std::cout, std::cin
and so-forth. You may vaguely remember namespaces in C if you read through my notes, however, we didn't discuss
them much because aside from using the typedef keyword, they weren't a large part of the syntax. As I briefly
went over at some earlier point, namespaces essentially help us with scope. If we have a function foo() in
library x and function foo() in library y, C++ needs to know which foo() we are referring to. We can also
declare our own namespaces by wrapping our methods in a namespace wrapper. The general syntax is as follows:

\begin{cpplst}

namespace namespace_name {
    method() {
        // Code block
    }
}

\end{cpplst}

namespace is a keyword stating that we are declaring a new namespace, namespace\_name is the name that we want
to call our namespace, and anything else within our namespace wrapper must now be prepended with
namespace\_name e.g. mynamespace::method(); This can get somewhat confusing since we can have nested
namespaces, where we have namespaces within other namespaces by wrapping them within each other. Here's an
example:

\begin{cpplst}

namespace namespace1 {
    foo() {
        // Code block
    }

    namespace namespace2 {
        foo() {
            // Code block
        }
    }
}

\end{cpplst}

Now, in order to call foo() from namespace1, we would call it as: namespace1::foo(); or if we wanted to call
foo() from namespace2: namespace1::namespace2::foo(); We can use the "using" directive multiple times in our
code to tell C++ to look in multiple namespaces, but this can become dangerous. For example, adding both
"using namespace namespace1" and "using namespace namespace2" would cause ambiguity once again, which
ironically, was supposed to be the goal of separating the 2 definitions of foo() into their own namespaces.

Because of the possibility of reintroducing ambiguity with the using directive, it is somewhat of a
controversial topic within the C++ community. I think I’m inclined to agree that it should generally be
discouraged in production code/professional code, however, if you know what you are doing then it may be
acceptable in personal projects. Just note that when we "using namespace std;" we are sort of missing the point
as to why namespaces exist in the first place, so proceed with caution.

\section{The Unexpected Difference Between Classes and Structs}

If you've seen any C++ code being written, or have done a bit yourself, you have probably questioned what the
difference between a struct and a class is. There is 1 and only 1 difference between a struct and a class in
C++, and that is that classes are private by default, and structs are public by default. That is legitimately
the only difference, and if you're coming from C, you may be wondering how that could be the case. After all,
structs don't have constructors right? Well, in C++, a struct can indeed have constructors. So for example, I
might have a class that appears like the following:

\begin{cpplst}

class MyClass
{
    std::string color;
    int len;
    bool is_true;

public:
    MyClass(std::string color, int len, bool is_true);
    ~MyClass();
};

\end{cpplst}

Note that the instance variables are private by default, and are therefore not visible to anything external of
the class itself, hence why we need to explicitly state that the constructor/destructor are public methods. But
if we simply take the exact same code and replace 'class' with 'struct':

\begin{cpplst}

struct MyClass
{
    std::string color;
    int len;
    bool is_true;

    MyClass(std::string color, int len, bool is_true);
    ~MyClass();
};

\end{cpplst}

Now it is no longer necessary to make the methods public, although without a private modifier, the instance
variables are also public now. I will include another code snippet down below to demonstrate an actual
implementation of this struct in a program:

\begin{cpplst}

#include <iostream>

struct MyClass
{
    std::string color;
    int len;
    bool is_true;

    MyClass(std::string color, int len, bool is_true);
    ~MyClass();
};

MyClass::MyClass(std::string color, int len, bool is_true)
{
    this->color = color;
    this->len = len;
    this->setValue = is_true;
}

MyClass::~MyClass()
{}

int main(void)
{
    struct MyClass myclass1("red", 5, true);
    std::cout << myclass1.color << std::endl;
    std::cin;
}

\end{cpplst}

Here you can see that I'm creating an instance of a struct, not a class, and because my constructor is public
by default, a can print out the myclass1's color value. If I were to change struct to class however, then I
get a compile time error "cannot access private member declared in class 'MyClass'".

So that then begs the question... If struct and class are essentially identical, why do we even need both? The
simple answer to this is to maintain backwards compatibility with C, similar to why C++ keeps pointers. You
could go your entire C++ career without ever creating a struct. However, it is up to you if or how you
implement structs in your code, and this might be an advantage to you. For instance, I tend to use structs
when I need to group related data which doesn't comport itself well as an "object" per-se. I'd use a class for
more complex logic, if I want to be inheriting from other classes, or creating copy constructors, or creating
member functions, etc. You do not have to do it my way, but I figured it'd be useful to share how you could
use structs if you so choose to.

\section{Object Oriented Programming (OOP)}

At this point in the document, we're going to take a bit of a detour into what I would argue sets C++ apart
the most from a language like C, which is its object-oriented capabilities. C++ has some pretty interesting
ways of handling OOP, to say the least.

\subsection{Inheritance and Polymorphism}

One of the most difficult aspects to grasp in C++ is how it deals with inheritance. You see, C++ was really
one of the first languages to popularize the OOP paradigm, and as a result, a few questionable design choices
were made. Let's discuss a few of those design choices. The first design choice, which was intentially
chosen by Stroustrup, is that there is no universal root class. In Java, and most other modern OOP languages,
there is a root class (in the case of Java, this would be the Object class), from which all classes are
implicitly derived. Because there is no root class in C++, there is a much heavier reliance on templates and
multiple inheritance. It also leads to other strange behaviour, such as type casting errors when trying to cast
one class to another. In Java, if you try casting Foo to Bar when Bar does not inherit Foo, an exception will
be thrown. In C++, this behavior is undefined. Multiple inheritance is perhaps the greatest sin commited by
C++. In Java, a class may only extend one base class, but in C++, a class may derive from multiple classes.
This leads to all sorts of confusion and disarray. A classic absurdity that arises from multiple inheritance
is the infamous diamond problem. This occurs when one class inherits from 2 base classes, which themselves
share the same base class. This relationship creates a diamond shaped dependency graph when visualized
hierarchically. The issue here is that child classes automatically inherit all properties of their parents.
This includes both member variables and member functions. If class A exists at the top of the diamond, and has
a public member function named foo(), then its children B and C necessarily contain foo() as well. You may
consider analysing this example for reference:

\begin{cpplst}

#include <iostream>

using namespace std;

class A
{
public:
    void foo()
    {
        cout << "foo" << endl;
    }
};

class B : public A
{};

class C : public A
{};

class D : public B, public C
{};

int main()
{
    D d;
    d.foo(); // Compile-time error: Member 'foo' found in multiple base-class subobjects of type 'A'
}

\end{cpplst}

This can be resolved by either casting d to be of type B or C: ((C)d).foo(), using the scope resolution
operator, or by using something known as virtual inheritance, which we will discuss in a bit. In general, it
is recommended that you concienciously design your code in a manner which avoids multiple-inheritance.

I don't want to gloss over what I said earlier about child classes inheriting all member variables and member
functions from their parents, as I believe that this is crucial to your understanding of how inheritance works
in C++. Since a derived class always inherits all properties of its parent, it necessarily contains at the
very least, those same properties, plus, optionally, any additional properties which it declares. Very important
to note, however, is that just because it inherits all properties of its parent, this does not mean that it
inherits all access to those properties. For instance, a child class may not access private members which belong
to its parent. Additionally, a child class cannot initialize members of the base class using an initializer list
in its constructor.

\subsection{Virtual Functions and Virtual Inheritance}

I mentioned that we would discuss using virtual inheritance as a means of bypassing the diamond problem, so
that's what we will now discuss. Basically, you can think of virtual inheritance as being the same as the
@Override annotation in Java. Virtual inheritance does have subtle differences though, but the end result is the
same. In order to understand how virtual inheritance works, you must understand something known as the V-table
(virtual table). When a member function is declared virtual, the class which declared the virtual function
immediately receives a pointer to a dyamically allocated v-table. The v-table is just a table of function
pointers, which contains a pointer to each implementation of the virtual function. For instance, if class Foo
has a virtual member function named foo(), it will recieve a pointer to a v-table that contains all current
implementations of foo(). If a class named Bar extends Foo, since child classes automatically inherit all
properties of its parent, Bar too, will inherit the same v-table. Then if Bar overloads the virtual function
foo(), the v-table will now contain two function pointers: one to the version of foo() belonging to class Foo,
and the other version of foo(), belonging to class Bar. The v-table will continue to dynamically grow in size
as more and more classes overload the function foo().

So, what are the rules for virtual functions in C++? Basically, the base class must place the virtual keyword
in front of any member function which it wishes to allow its children to overload. The child classes do not
necessarily need to put the virtual keyword in front of the function overload, however, I strongly implore you
to consider including it, so that readers of your code understand that it is being overloaded! But technically
speaking, at the bare minimum, the base class is the only class which must explicitly declare the function as
virtual.

\subsection{Pure Virtual Functions}

In C++, there is no such thing as the implements keyword. You may be asking yourself then, "how do I implement
interfaces in C++"? Interfaces as we’re used to them do not exist in C++, and therefore, cannot be implemented
technically speaking. We can, however, use a class filled with functions known as pure virtual functions. This
essentially turns the class into an abstract class, meaning that it cannot be instantiated. Other classes may
extend this "abstract" class (remember, abstract classes don't really exist in C++, but for all intents and
purposes, classes which have pure virtual functions are abstract) and must then create a local definition for
the pure virtual function, similar to an interface. So how do we mark a function as being "pure" virtual
rather than just virtual? Well, the syntax is a bit odd, but we essentially set the function equal to 0 like
so:

\begin{cpplst}

class Shape
{
public:
    // Pure virtual function
    virtual void calculateArea() = 0;
};

\end{cpplst}

Now anything that derives from shape must implement its own definition for calculateArea(), otherwise a
compile-time error will be thrown. Note that pure virtual function inheritance is very similar to virtual
inheritance, with the key difference being that the parent class gets to have its own definition for a member
function with normal virtual inheritance (as do its children), but with pure virtual inheritance, only the
child classes get to have their own definitions.

\subsection{Virtual vs Override vs Final}

C++ has both a virtual keyword and an override identifier. This can be confusing because new C++ programmers
aren't sure when it is necessary to use virtual or when to use override. The answer is that it really comes
down to preference. The virtual keyword must be present before a member function declaration in the base class
for it (and by extension, further overrides to it in decendent classes) to be placed in a vtable. Children of
the base class may optionally include the virtual keyword, although it is not a requirement for the compiler.
Similarly, the override identifier is entirely optional. If placed after a function declaration, the override
keyword ensures that the function's signature matches that of the base class'. The override identifier may only
be used if the virtual keyword is also explicitly used. We can use the final identifier rather than, or in
tandem with the override identifier, to suggest that any classes which inherrit from the current class may not
override the member function, effectively preventing further additions to the vtable. Here is an example:

\begin{cpplst}

class A
{
    virtual void foo()
    {
        // Some code
    }
};

class B : public A
{
    virtual void foo() override
    {
        // Some code
    }
};

class C : public B
{
    virtual void foo() final
    {
        // Some code
    }
}

class D : public C
{
    virtual void foo() // Error: Declaration of 'foo' overrides a 'final' function
    {
        // Some code
    }
};

\end{cpplst}

\section{Accessing Private Members Using the friend Keyword}

In my opinion, perhaps one of the most contentious features of C++ is its ability to allow other functions
or classes to bypass access restrictions using the friend keyword. A class may opt to make its members
accessible to other specified classes or functions without making them public to all external entities. In
other words, we can make other global functions or classes a trusted 'friend' of the class, stating that they
have exclusive permissions to bypass any access modifiers or implicit access restrictions. Let's first look
at how we can make another class a friend of our class. This will allow the other class to access all members
of the current class at any moment:

\begin{cpplst}

class A; // Forward class declaration

class B
{
public:
    B() = default;
    ~B() = default;

    void foo(A &a);
};

class A
{
public:
    A() = default;
    ~A() = default;

private:
    std::string b_can_access;
    friend class B;
};

\end{cpplst}

Here, we've marked B as a friend of A. This allows B to access all members belonging to A that are private.
In the example, the only private member of A happens to be b\_can\_access

\section{Member Variable Initialization Via Constructor}

There are 3 primary methods of initializing member variables via constructor in C++. The most basic method is
to take in an argument for each member variable in the class that needs to get set when the constructor is
invoked. The parameter's name must differ from that of the member variable, but must also be of the same type.
For example, assume our class Foo has an int, a float, and a std::string:

\begin{cpplst}

class Foo
{
public:
    Foo(int integer, float decimal, std::string sentence);

private:
    int m_integer;
    float m_decimal;
    std::string m_sentence;
}

\end{cpplst}

Now we can define the constructor as such:

\begin{cpplst}

Foo::Foo(int integer, float decimal, std::string sentence)
{
    m_integer = integer;
    m_decimal = decimal;
    m_sentence = sentence;
}

\end{cpplst}

Of course, there is another way of doing the same thing using the "this" keyword, which is a compiler
intrinsic that expands to a pointer of the enclosing class. Rather than using different names for the member
variables and the constructor arguments, we can instead access member variables with "this", which removes
ambiguity between the two variables. Pretend we have the same class Foo, but this time I've stripped away the
m\_ prefix from the member variables. Here is the new constructor definition:

\begin{cpplst}

Foo::Foo(int integer, float decimal, std::string sentence)
{
    this->integer = integer;
    this->decimal = decimal;
    this->sentence = sentence;
}

\end{cpplst}

Between the two methods presented so far, which you use is entirely a matter of preference. There is, however,
a third alternative for member initialization, which has a practical benefit over the former candidates. The
third method to which I am referring are initializer lists. Initializer lists are unique due to the fact that
they implicitly prevent double initialization. In our previous examples, the sentence member variable would be
initialized once during the class declaration as an empty string, and then again during the assignment within
the constructor. Assignment via initializer list takes precedence over any default initialization within the
class declaration, which is a very miniscule optimization. On top of this though, initializer lists are, in my
opinion, a bit more legible, since they separate assignment operations from any other logical operations which
need to take place within the constructor. The initializer list goes in between the closing bracket of the
constructor's argument list and the opening curly brace of the constructor’s code block. Here's what this looks
like:

\begin{cpplst}

Foo::Foo(int integer, float decimal, std::string sentence) :
    m_integer(integer), m_decimal(decimal), m_sentence(sentence)
{
    // Any additional logic can go here
}

\end{cpplst}

Initializer lists are also the method used to chain constructors. In C++ chaining constructors is known as
"constructor delegation". This was introduced in C++11 so previous versions will not support constructor
delegation. Take the following example code:

\begin{cpplst}

class DelegationExample
{
public:
    DelegationExample();
    DelegationExample(int n);
    void setNumber(int n);

private:
    int number;
};

DelegationExample::DelegationExample()
    : DelegationExample(5)
{}

DelegationExample::DelegationExample(int n)
{
    setNumber(n);
}

void DelegationExample::setNumber(int n)
{
    number = n;
}

int main()
{
    DelegationExample delInstance = new DelegationExample();
    return 0;
}

\end{cpplst}

In this example, when delInstance gets created, the default constructor is called. Because DelegationExample
is in our initializer list, however, before the code within the default constructor is called (not that there
is any in this example), the constructor with the int n parameter is called, which calls setNumber and sets
number = 5. The call stack will then begin to return and the stack pointer will go back to run any code within
the default constructor since it didn’t get a chance to once the initalizer list took over. It should be noted
that initializer lists can also work for objects but there can be a lot of confusion about that. The following
code is from stack overflow and demonstrates the different ways in which you could create an object with an
initializer list and default constructor and the outcome of each method:

\begin{cpplst}

class NewFoo
{
    int x;
    int y;
};

// Version 1:
class Bar1
{
private:
    NewFoo f;
};

// Version 2:
class Bar2
{
 public:
     Bar2()
     {}

private:
     NewFoo f;
};

// Version 3:
class Bar3
{
public:
    Bar3() : f()
    {}

private:
    NewFoo f;
};

int main()
{
    Bar1 b1a;           // x and y not  initialized
    Bar1 b1b = Bar1();  // x and y zero initialized
    Bar2 b2a;           // x and y not  initialized
    Bar2 b2b = Bar2();  // x and y not  initialized
    Bar3 b3a;           // x and y zero initialized
    Bar3 b3b = Bar3();  // x and y zero initialized
}

\end{cpplst}

This example was borrowed from this stack overflow post:
\href{https://stackoverflow.com/questions/13238234/initializer-list-for-objects-with-default-constructor}{%
Initializer list for objects with default constructor}

\section{Special Member Functions}

C++ generates "special member functions" for us when we create a new class. As we've seen, the default
constructor is one such member function which is automatically generated for us if we do not create it
explicitly. This makes sense, as without any constructor, we would not be able to instantiate the object
(which we presumably want to do). C++ auto-generates other member functions, namely, a copy constructor,
copy-assignment operator, move-assignment operator, destructor, and prospective destructor. Here is a summary
for each:

\begin{itemize}


\item{%
    \textbf{Default constructor}: A no-parameter constructor which allows an object to be instantiated.
}

\item{%
    \textbf{Copy constructor}: A constructor which takes as a parameter a reference to the outer class with the
    intention of instantiating a new instance of the class by copying the attributes of the instance passed into
    the constructor, effectively making a copy of said object.
}

\item{%
    \textbf{Move constructor}: Works similar to the copy constructor, but transfers ownership of the reference
    to the rvalue into the lvalue, thus invalidating the rvalue.
}

\item{%
    \textbf{Copy-assignment operator}: Similar to the copy constructor, but overloads the assignment operator
    (=). The right operand (rvalue) of the assignment expression is passed into the assignment operator
    function overload as a reference and the left operand (lvalue) inherits all properties of the right
    operand.
}

\item{%
    \textbf{Move-assignment operator}: Works similar to the copy-assignment operator, but transfers ownership
    of the reference to the rvalue to the lvalue, thus invalidating the rvalue.
}

\item{%
    \textbf{Destructor}: A function invoked when the delete keyword is explicitly used to cleanup the object.
}

\item{%
    \textbf{Prospective destructor}: A class may have multiple prospective destructors i.e. potential
    destructors, but only one actual destructor. This is useful in the case of, for example, templated
    classes, in which you may want to have the compiler infer one of multiple destructors depending upon a
    generic type or other conditional.
}

\end{itemize}

\subsection{Deleting Member Functions}

As of C++ 11, we have the ability to delete member functions, including special functions such as the ones
listed in the previous section. We can do this using the delete keyword. We can also specify which
constructor the compiler ought to treat as the default constructor with the default keyword. Here is an
example:

\begin{cpplst}

class Foo
{
    Foo();
    Foo(const Foo&) = delete;
    Foo &operator =(const Foo&) = delete;
};

\end{cpplst}

In this example we delete the auto-generated copy constructor, as well as the auto-generated copy operator,
making it so that we cannot make copies of any instances of Foo:

\begin{cpplst}
int main(void)
{
    Foo one = Foo();    // Okay
    Foo two = Foo();    // Okay
    Foo three(one);     // Call to deleted constructor of 'Foo'
    two = one;          // Overload resolution selected deleted operator '='
}
\end{cpplst}

The delete keyword can be used on non-auto-generated member functions as well. One reason you might use this
is to avoid unwanted type promotion. For example, we can prevent type promotion from float to double from
succeeding like so:

\begin{cpplst}

void no_floats_allowed(float) = delete;
void no_floats_allowed(double param) { return; }

\end{cpplst}

In the example above, we prevent the call to no\_floats\_allowed() from succeeding if the argument is a
float (normally it would be promoted to a double to work with the function). Note, however, that an int will
still work in this case. Rather than create another delete function for int, we can use templates to make
this process cleaner:

\begin{cpplst}

template<typename T>
void no_floats_allowed(T) = delete;
void no_floats_allowed(double param) { return; }

\end{cpplst}

Another reason for deleting member functions is to remove them in child classes that inherit from a base
class.

\subsection{Creating Default Definitions of Special Member Functions}

We are able to spare some typing by utilizing the 'default' keyword in C++. Similar to delete, default was
also introduced in C++11. The default keyword is primarily useful for the aforementioned special member
functions which are implicitly defined for us. We can make these implicit declaratios more explicit by
utilizing the the default keyword. Up until now, you'll have seen me make a lot of empty destructor
definitions, which is not necessary. Here's an easier way of doing the same thing:

\begin{cpplst}

class Foo
{
public:
    // Explicitly tell the compiler to generate a default contructor/destructor for Foo
    Foo() = default;
    ~Foo() = default;
};

\end{cpplst}

\section{Move Semantics}

C++ has a concept known as move semantics, which can (in my opinion) really confuse a lot of programmers who
are new to the language. It will be helpful if you're familiar with ownership and the borrow checker in Rust,
though you should still be able to grasp the concept if not. Move constructors allow us to transfer
ownership of a value from one entity to another. We invoke the move constructor via std::move(). In some
cases, C++ uses move semantics implicitly, such as when returning objects from a function. Move semantics can
be used in regular functions as well.

The difference between moving and copying is that copying allocates memory for the copy and then copies the
contents of the initial value over to the newly allocated space, whereas moving an object effectively creates
a pointer to the original object but invalidates the original owner so that we don't have two pointers
accessing the same memory. Unlike a language like Rust, C++ does not enforce this invalidation, meaning that
we can still access the contents of the original owner, though they will be in an unknown state and their
contents may get overwritten. Move semantics utilize a double ampersand to indicate that were moving, not just
borrowing a reference to the original object. Here's an example which illustrates a valid usage of the special
move constructor member function:

\begin{cpplst}

#include <iostream>
#include <utility>

class Foo
{
public:
    Foo() = default;
    Foo(Foo &foo) = delete;
    Foo(Foo &&foo) = default;
    ~Foo() = default;
};

int main(void)
{
    Foo a = Foo();
    Foo b = std::move(a);
    // a is invalidated. Using it is undefined behavior
}

\end{cpplst}

Note in this example that if the move constructor were deleted, then the call to std::move() would fail.
std::move() belongs to the utility header, so that ought to be included. Note that explicitly declaring the
move constructor using the default keyword will actually implicitly delete the copy constructor because it
assumes if you declare one explicitly then you would have meant to declare the other explicitly. In other
words, if you intend to use both the copy and move constructors, either declare both explicitly with the
default keyword, or declare neither and have the compiler generate them implicitly for you. The same logic
applies to the copy-assignment and move-assignment constructors.

An interview question that I've heard is to ask what happens when you call move on a const object. Const
entities have no ability to be changed at runtime, including transfering ownership. In this unique case,
std::move fails silently and will actually just perform a copy.

\section{constexpr}

The C++ keyword constexpr, pronounced "const expression" was introduced in C++ 11. It informs the compiler
that a variable or function can be computed once at compile time, and then substituted everywhere it's
referenced. The constexpr keyword shares the same property as the const keyword, meaning that variables or
functions declared with constexpr will be immutable. Here's an example of how to use constexpr:

\begin{cpplst}

constexpr float circumference = 2.0f * M_PI;

\end{cpplst}

The variable circumference would normally be computed at runtime each time it's referenced, however, placing
constexpr before the statement will cause the result to be computed at compile time and then reused, similar
to how macros work. Note that expressions marked with constexpr are only valid if all entities in the
statement are also marked with constexpr (or const in the case of variables). For example, the following is
an error:

\begin{cpplst}

int j = 0;
constexpr int k = j + 1; // Fails since j was not qualified with constexpr or const

\end{cpplst}

Likewise, the following is also an error:

\begin{cpplst}

#include <cmath>
#include <complex>

// Fails since std::exp() is not a constexpr
constexpr std::complex<double> eulers_ident = std::exp(std::complex<double>(0.0, M_PI)) + 1.0;

\end{cpplst}

\section{C++ Style Casts vs C-Style Casts}

Casting in C++ is actually quite the conundrum, believe it or not. To maintain backwards compatibility with
C,  C++ implements C-style casts (using brackets), but the implementation of C-style casts function quite
differently than they do in C (more on that later). The typical way of casting in C was simply to use the
round brackets with the target datatype in between to indicate that a value should be cast to that type
before variable assignment. This would look something like the following: int asciiToDec = (int)'a';  Here
the character 'a' would be cast to int, and become 97 before being assigned to variable asciiToDec. However,
I also mentioned that C++ was different in that casting a void pointer must be explicit. C++ has 4 standard
types of cast that must be declared explicitly. Note that C++ has a really odd feature that C didn’t have
whereby we can swap the bracket position for the variable and the type being cast to in a C-style cast. Here
is an example:

\begin{cpplst}

char a = 'a';
// Regular method:
// int b = (int)a;
// Alternative method:
int b = int(a);

\end{cpplst}

I say this now so that hopefully the syntax for C++ casts makes more sense as we look at them. Without
further ado, we’ll begin with the first type of C++ cast: const\_cast.

\begin{itemize}

\item{%
    \textbf{const\_cast<T>():} A const\_cast will actually alter whether or not a variable is read-only. Ex:

    \begin{cpplst}

    int main()
    {
        const int a = 9;
        const_case<int&>(a) = 4; // This is a valid reassignment!
    }

    \end{cpplst}
}

\item{%
    \textbf{static\_cast<T>():} The static\_cast performs a non-polymorphic cast. For example, it can
    cast a base class pointer to a derived class pointer. Unlike dynamic cast, static cast occurs at compile
    time. In C++, we do not need to explicitly use static cast to downcast from a base pointer to another
    class type which inherits from the base class, however, it is advised due to it being idiomatic. By using
    static cast, we differentiate between const, dynamic, and reinterpret casts, unlike C-style casts, which
    have no visual method of differentiating between each type. Ex:

    \begin{cpplst}

    class A {};
    class B : public A {};

    int main()
    {
        A a;
        B *b = static_cast<B*>(&a);
    }

    \end{cpplst}
}

\item{%
    \textbf{reinterpret\_cast<T>():} The reinterpret\_cast is essentially the same as static cast, but
    whereas static cast has some compile time checks to ensure that the conversions of types make
    intuitive sense (e.g. casting a double to an int fails), reinterpret cast has no cares about bit twidling
    to fit a data type that does not make sense for the actual underlying data. This is essentially
    equivallent to storing some data of one type in a void pointer in C, and then reinterpreting that data as
    another type which may or may not make sense. This practice is known as type punning. Ex:

    \begin{cpplst}

    #include <iostream>

    struct A
    {
        int x = 5;
    };

    struct B
    {
        int x = 10;
    };

    int main()
    {
        A a;
        B *b = reinterpret_cast<B*>(&a);
        std::cout << b->x << std::endl; // Prints 5
    }

    \end{cpplst}
}

\item{%
    \textbf{dynamic\_cast<T>():} The dynamic cast performs a polymorphic cast. They operate at runtime and
    will return nullptr if the cast cannot succeed. The primary use of this is to downcast a pointer or
    reference to a base class into another class type which inherits from the base class. This is only
    possible if the base class has at least one virtual function. Ex:

    \begin{cpplst}

    class A
    {
    public:
        int x;
        A() : x(7) {}
        virtual void foo() {}
    };

    class B : public A
    {
    public:
        int x;
        B() : x(3) {}
        virtual void foo() override {}
    };

    int main()
    {
        B *b = new B();
        auto b2a = dynamic_cast<A*>(b);

        if (b2a)
        {
            cout << b2a->x << endl; // Prints 7
        }
    }

    \end{cpplst}
}

\end{itemize}

\subsection{How C-Style Casts Work in C++}

As mentioned earlier, C-style casts have a different implementation within C++, which is obfuscated from you,
the programmer, and which makes it rather dangerous to use. When performing a C-style cast, it will attempt
the following C++ casts under the hood, in order, until one succeeds:

\begin{enumerate}

\item const\_cast

\item static\_cast

\item static\_cast*, then const\_cast

\item reinterpret\_cast

\item reinterpret\_cast, then const\_cast

\end{enumerate}

This is pretty dangerous right of the bat, because lets say that you have a const variable, and then you
perform a C-style cast to change its type, however you forget to add the const qualifier in front of the type
you’re casting to. The compiler will attempt the first C++ cast, being const\_cast. Since we’re changing the
type of the variable, the compiler will not accept this and continue to step 2. Static cast will also fail,
due to the fact that we accidentally failed to add the const qualifer to the type being cast to. The compiler
will then try 3, which will succeed, since it will change the variables type and remove the const qualifier
silently, without warning us! This is even scarier if we perform a C-style cast from one type to another when
those two types have no relationship with one another. A static\_cast will at least catch this and throw an
error, but a C-style cast will just end up doing a reinterpret\_cast whether you like it or not. This is why
it is so heavily discouraged to use C-style casts in C++, and why its best to stick to the primary C++ casts
even though they can be mildly more annoying to type out.

\section{Operator Overloading}

Another feature that I am actually quite fond of in C++ (and I think many other people like as well), is
operator overloading. This is pretty unique to C++ (though I’m sure other languages have this ability), a
sort of C++ staple if you will. Have you ever wished to be able to check if 2 objects are equivellant using
==, or perhaps wanted to increment every variable in an array using ++? This is possible in C++ because we
can overload the definitions of operators and create our own definitions. In C++, operators are treated as
functions, where the statements to the left and right of the operator are parameters. For example, let's say
that we wanted to set an object of a parent class A, equal to an instance of the derived class, B (A a = B;).
This is possible in C++ even without operator overloading, but my point is that the argument on the left of
the = sign is treated as a parameter, as is B on the right. If = was the name of the function, this would
sort of be like calling "=(a, B);" although this is not completely accurate. Anyhoo, parameters are implicitly
passed for unary operators such as ++, --, \&, etc. And are explicitely passed for binary operators such as
<<, >>, ==, =, +, -, /, *, \%, etc. So how do we actually overload an operator. Well, let me preface by
saying that operator overloading can only be performed on classes. Within a class, we can declare a function
using the "operator" keyword followed by the operator we want to overload.

Let’s first say that we have a class called OpOverload which contains a member variable called "number". We
want to be able to use the pre and post increment operators on instances of this class. For example, we want
to be able to do the following:

\begin{cpplst}

OpOverload op;
++op; // pre increment
op++; // post increment

\end{cpplst}

where the pre and post increment operators will increment the "number" associated with the instance of the
class. I will define the class, and the definitions for pre and post increment and explain afterwards:

\begin{cpplst}

#include <iostream>

class OpOverload
{
private:
   int number;

public:
    OpOverload() = default;
    ~OpOverload() = default;

    // Pre-increment
    OpOverload& operator++()
    {
        this->number++;
        return *this;
    }

    // Post-increment
    OpOverload& operator++(int)
    {
        OpOverload& temp = *this;
        temp.number = this->number;
        this->number++;
        return temp;
    }
};

int main()
{
    OpOverload op;
    ++op;
    op++;
}

\end{cpplst}

Alright, I’m sure this is quite confusing, which is to be expected because the syntax isn’t exactly pretty.
Let’s look at pre-increment first. Recall that when we say ++op; we are sort of calling the ++ function with
op as a parameter. Because the pre-increment operator is unary, op is passed implicitely. Notice that we also
return a reference of the class. This is because whichever object we are pre-incrementing will essentially
get set equal to the return value of the operator function. In other words, our instance, op, will get set =
to the reference which is returned from our operator overload. So, we call ++(); then, we acces the member
variable "number" which belongs to "this", which is the implicit argument that we passed, op. But hold on,
why are we using post-increment and not pre-increment on number? Well in this case it doesn’t matter if we
increment the number using pre or post increment because all that matters is what gets returned. Either way,
number gets incremented before we return the reference to OpOverload, so no harm is done. As for the return
value, we must dereference "this" before returning it since it is a pointer and we need to convert it to a
reference. I hope you followed that, but I understand that it’s confusing.

As for the post increment, well this is perhaps even more confusing. With post increment, we are also calling
++(); but then that begs the question: what differentiates the pre and post increment overloads? How does C++
know which you are overloading? Well this is why we placed that ominous int parameter: in order for C++ to
recognize it as a post increment operator. You couldv’e given this parameter a name like int i, however,
since it is useless and never gets used except to check that this is a post increment overload, I did not
include the variable name. Moving onto the code, I create a temporary reference called temp which gets set
equal to the implit parameter, op (once again, dereference to convert pointer to reference). We set the
member variable "number" of the temporary reference = to the current value of "number" in "this". Then, we
increment this->number. Notice though that we return temp, and not this. Recall that I said only what we
return matters. Now op will be set to the reference which was returned, which was temp, so it's member,
"number" will remain the same, until we access number on the next line, where it will be incremented since we
said this->number++; It’s all very confusing I know. This stuff simply comes with practice.

Now let’s say that we want to create a sort of "toString()" function like we have in Java, and overload the
redirection operator << to print the member variable "number" of the object like so std::cout <<
objectInstance << std::endl; Here is the code for that:

\begin{cpplst}

#include <iostream>

class OpOverload
{
private:
   int number;

public:
    OpOverload() = default
    ~OpOverload() = default

    // Pre-increment
    OpOverload& operator++()
    {
        this->number++;
        return *this;
    }

    // Post-increment
    OpOverload& operator++(int)
    {
        OpOverload& temp = *this;
        temp.number = this->number;
        this->number++;
        return temp;
    }

    friend std::ostream& operator<<(std::ostream &os, const OpOverload &op)
    {
        os << "Object’s number variable = " << op.number;
        return os;
    }
};

int main()
{
    OpOverload op;
    ++op;
    op++;
    std::cout << op << std::endl;
}

\end{cpplst}

Output: Object’s number variable = 2

Notice the use of a new keyword for this one: friend. friend allows external functions or objects to access
our classes private and public members. Since ostream must access op.number, we must declare this function as
a friend function, essentially granting ostream permission to access our private/public members in OpOverload.
ostream is simply short for output stream and must be returned when overloading the output redirection
operator. The const keyword is used for our reference of OpOverload since it’s data is not modified in this
function.

Here is another slightly more complex example of operator overloading where we overload the post increment
operator to act upon each member of a collection simultaneously (in this case std::Vector):

\begin{cpplst}

#include <vector>
#include <iostream>

template <class T>
class Vec : public std::vector<T>
{
public:
   std::vector<T> m_vec;

   Vec(std::initializer_list<T> l) : m_vec(l) {}
   ~Vec() = default;

   void operator++(int)
   {
       for (auto &i : this->m_vec)
       {
           i++;
       }
   }
};

int main()
{
    Vec<float> vec{ 1.0f, 1.0f, 1.0f };
    vec++;

    for (auto i : vec.m_vec)
    {
        std::cout << i << " ";
    }
    std::cout << std::endl;
}

\end{cpplst}

So, let me begin to explain myself here. Since we cannot access the vector class directly, the way in which
we overload it is to extend it. This is why I create a new class called Vec : public std::vector<T>. You’ll
notice that the class has been templated, i.e. it accepts any data type from the user when we create an
instance of it, and anywhere where T arises, we can replace it with the data type that was passed. Within the
constructor, we take in one parameter, std::initializer\_list<T> l. Initializer list is an object which
accepts a list of variables enclosed in {} (an initializer list). This way, when we create an instance of the
class, we can pass in a list of elements that we want to add to the vector. The class contains a member
variable, m\_vec, which is the vector that we are actually modifying. The constructor also initializes m\_vec
with the initializer list that we pass in.  Finally, we get to the overload of the post increment operator.
This time we don’t need to return anything since the instance of the object is not being modified, only
m\_vec is. An advanced for loop says that for every element in this->m\_vec (remember that this is the
implicit lefthand parameter; in our case vec), we want to create a reference called i (a reference to the
current next element in m\_vec). The auto keyword is common in advanced for loops, and in this case makes our
life easier since the data type could vary. Alternatively, we could’ve said for(T\& i : this->m\_vec).
Anyways, we simply increment each element with i++; and that’s pretty much it. The second for loop simply
accesses m\_vec and prints every element to standard out. Notice that this even works for characters:

\begin{cpplst}

Vec<char> vec{'a', 'b', 'c'};
vec++;

\end{cpplst}

Outputs: b c d

One last trick I want to show of is that we can overload the new and delete keywords, since C++ actually
treats them as operators. Overloading new and delete is seldomly used and is probably best avoided in
general, however, it does give us the flexibility to effectively override the default allocator and
deallocator if you so desire.

\begin{cpplst}

void* operator new(size_t size)
{
    std::cout << "Allocated " << size << " bytes" << std::endl;
    return static_cast<void*>(std::malloc(size));
}

void operator delete(void *args)
{
    std::cout << "Deleted" << std::endl;
}

\end{cpplst}

\section{Enums}

Enums in C++ come in two forms. We have C-style enums, and then we have class-based enums, which are a new
C++ addition. Let's start with C-style enums. These are effectively identical to how you would declare an enum
in C, but with one minor difference, which is that we can optionally specify an integer type as the
underlying type used by the enum. Here's an example:

\begin{cpplst}
enum Color : uint32_t // Optionally specifying uint32_t as the underlying type
{
    RED     = 0xFF0000FF,
    GREEN   = 0x00FF00FF,
    BLUE    = 0x0000FFFF
};
\end{cpplst}

Class-based enums are pretty much the same as C-style enums, but with some slight differences. Class-based
enums treat their members as if they were static, meaning that in order to use an enum, we have to access it
through the scope of the outer class e.g. ENUM::TYPE. The other distinguishing feature is that we can't
perform implicit conversions from a numeric type to a class-based enum, whereas we can do implicit conversions
between integer types and C-style enums. This is definitely a good reason to prefer class-based enums in your
code. Here's an example:

\begin{cpplst}
enum class DrawCmd
{
    REDRAW,
    FILL,
    CLEAR
};

// ...

DrawCmd cmd = DrawCmd::REDRAW;
if (cmd == 0) // Invalid operands to binary expression ('DrawCmd' and 'int')
{
    // Do something
}
\end{cpplst}

Notice how the if statement throws an error because even though the value of cmd does happen to be 0, the
compiler treats DrawCmd::REDRAW as a distinct type apart from int. This code would work fine for C-style
enums, however, since it can implicitly cast C-style enums to integers.

\section{Smart Pointers}

A lot of C++ developers will claim that using the new and delete keywords is evil, because raw pointers are
evil, and are to be shunned immediately. I personally think this is a very dramatic take, but I will admit
that smart pointers are a step in the right direction, and this idiom is being adopted in other languages like
Rust. What makes smart pointers appealing is that they are automatically deallocated when they go out of
scope. This means that we don't have to manually manage freeing/deleting allocations, which is nice because
sometimes ownership can get confusing. Smart pointers will still invoke new and delete under the hood, so
your constructors and destructors will work in the same way they did when manually invoking new and delete.
Let's take a look at all three smart pointer types and where they are useful.

\begin{itemize}

\item{%
    \textbf{unique\_ptr:} Unique pointers are the most common type of smart pointer in C++. A unique pointer
    is named such because it has sole ownership over the object it encapsulates. This means the only way to
    transfer the value held by the unique pointer would be via move semantics. Usually, it's good practice to
    only have one owner over any given object at a time anyways, so unique\_ptr should be the default go-to.
    Smart pointers have an interesting detail which actually caused me a lot of headache on a project that I
    was working on at one point. There are effectively two ways of initializing a smart pointer (in this case,
    a unique pointer). The first is to pass is a heap allocated object using the new keyword into
    std::make\_unique. The issue I was running into is that this method actually takes longer to initialize,
    which can cause performance problems if you're creating many smart pointers. The preferred method to
    initialize smart pointers is to directly pass in the arguments of the constructor for the object you're
    wanting to box. Since the class is provided in the template, std::make\_unique knows which constructor
    to invoke depending upon the arguments provided.

    %\begin{cpplst}
    %#include <memory>

    %// Valid, but less recommended
    %std::unique_ptr<Foo> a = std::make_uniqe<Foo>(new Foo(1, "example"));

    %// Preferred method
    %std::unique_ptr<Foo> b = std::make_unique<Foo>(1, "example");
    %\end{cpplst}

    The advantage of std::make\_unique() is primarily that it performs error handling and will throw an
    exception if something goes awry.
}

\item{%
    \textbf{shared\_ptr:} The second type of smart pointer in C++ is known as a shared\_ptr. Shared pointers,
    as the name would suggest, allow you to have multiple owners pointing to the same data. Shared pointers
    are also sometimes called reference count pointers. The reason they're sometimes called reference count
    pointers is because they have an internal member variable which increments each time a new reference is
    lent and which is decremented each time a reference is dropped. The internal count will start at something
    like 0. If the count is then decremented to -1 (indicating that the final reference was dropped) then the
    underlying memory is deallocated. The code for creating shared pointers is effectively the same as for
    creating unique pointers, except we use shared\_ptr as the type rather than unique\_ptr and
    std::make\_shared() instead of std::make\_unique();.

    It should be noted that unique pointers and shared pointers fall under the same category of being
    \textit{strong} references. This simply means that, unlike the next type of smart pointer we'll look at,
    the underlying memory is deallocated when we either go out of scope (in the case of unique pointers) or
    when the reference count reaches whatever number is indicative of there being no remaining owners (in the
    case of shared pointers). The use\_count() member function of shared pointers will print the strong count
    thereby indicating how many active references we have to the shared object.

    \begin{cpplst}
    #include <memory>

    std::shared_ptr<Foo> a = std::make_shared<Foo>();
    std::cout << "Strong count: " << a.use_count() << std::endl; // 1
    {
        std::shared_ptr<Foo> b = a; // Shares the memory address held by a with b
        std::cout << "Strong count: " << a.use_count() << std::endl; // 2
    }
    std::cout << "Strong count: " << a.use_count() << std::endl; // 1 (since b was dropped)
    \end{cpplst}
}

\item{%
    \textbf{weak\_ptr:} Our final type of smart pointer is known as the weak pointer. Weak pointers, unlike
    unique and shared pointers are considered to be a weak reference (as opposed to a strong reference). Weak
    pointers only really make sense in the context of shared pointers. A weak pointer can borrow a reference
    to the memory held by a shared pointer, but unlike creating a new shared pointer, the weak pointer will
    not decrement the reference count of the original owner when it goes out of scope. A weak pointer doesn't
    really care if the originating shared pointer has been destroyed or not. Of course, we need to perform
    some safety checks before we use a weak pointer in case the original owner \textit{has} been destroyed.
    Because of multithreading, we also need to create a lock over the weak pointer while we use it, so that
    another thread doesn't accidentally drop the last strong reference to the memory, thereby making further
    operations with the weak pointer invalid. We can do this using the lock() member function of
    std::weak\_ptr. Here's a sample:

    \begin{cpplst}
    #include <memory>

    std::shared_ptr<Foo> a = std::make_shared<Foo>();
    {
        std::weak_ptr<Foo> b = a;
        if (auto p = b.lock())
        {
            // Do something with b
        }
        else
        {
            std::cerr << "Could not lock weak pointer b" << std::endl;
        }
    }
    \end{cpplst}
}

\end{itemize}

When dealing with smart pointers of any kind, if you need to convert them into raw pointers, you can use the
get() member function. This will effectively return the underlying memory held by the smart pointer.

\section{STL Containers}

I would like to return the focus now to perhaps the most difficult aspect of C++ to master, which is the
Standard Template Library (STL). The STL is a library which implements basic data structures and algorithms,
such as vectors, maps, iterators, as well as algorithms for sorting, searching, and data manipulation. We’ve
already seen some of the containers which are a part of the STL, such as std::array and std::vector. The STL
was written sometime in the 80s, before the C++ language was even standardized. When C++ was eventually
standardized by the ISO/IEC, the language committee decided to model parts of the C++ standard library after
the STL. In other words, the standard C++ library implements its own version of the STL, which is similar,
and may even look identical in some cases to the end user, though the implementation details may differ
internally. Because they are so similar, some people (even those who understand the differences between the
standard C++ library and the STL) will claim that the standard C++ library is the STL, when in fact, it is not.

\section{Iterators}

Iterators are a behavioral design pattern, which are becoming more and more common in modern programming.
Iterators do as they suggest – they iterate over a collection or container in a linear (O(n)) way. You may
ask yourself, why do we use iterators if we can just use a for loop? Well the argument typically goes as
follows: For loops assume that the container uses indices when it may, in fact, not use them. For instance,
if we iterate over a linked list using a for loop and stopping when i == ll.size, this works fine, but the
end user may be inclined to assume that the ith element of the linked list can be accessed using the index
operator, as suggested by the variable i e.g. ll[i]. As we know, linked lists cannot be accessed in this
manner. An iterator, on the other hand, is agnostic about which type of collection it is iterating over. That
being said, although I’ve heard the argument that iterators should be used whenever possible for consistency,
I do not personally believe that they ought to replace for loops entirely. If using an interpreted language
such as JS, for loops can provide a big performance boost. For compiled languages, your milleage may vary.

In C++, iterators can be implemented by including the iterator header file. Each STL container has its own
namespace, which we can use to access that type’s implementation of iterator e.g., vector<int>::iterator or
list<string>::iterator. Notice that this gives us a consistent interface for declaring iterators, which
abstracts away the implementation details of iterator for each type of container. Once we have an iterator,
we set it equal to the element that we want to begin iterating at. Since this is usually the first element,
we can use the begin() function which is implemented by each STL container to access its first element. We
can then check if the iterator is smaller than container.end(), and if so increment the iterator. Here is
some example code:

\begin{cpplst}

#include <iostream>
#include <iterator>
#include <vector>

int main()
{
    vector<int> v = { 1, 2, 3, 4, 5 };
    vector<int>::iterator v_it;

    std::cout << "The vector elements are: ";
    for (v_it = v.begin(); v_it < v.end(); v_it++)
    {
        std::cout << *v_it << " ";
    }
    std::cout << std::endl;

    return 0;
}

\end{cpplst}

Note that the iterator must necessarily override the default pre and post increment/decrement operators. For
containers which are allocated in a contiguous memory region, the iterator may simply take advantage of
pointer arithmetic and jump forward by the size of it’s type and then check the address that the iterator is
pointing to to see if it matches with the final element’s address. For containers which may allocate memory
anywhere on the heap, such as a linked list, it would naturally need to override the increment/decrement
operators so that they point the iterator towards the next or previous element in the list. If what I just
said doesn’t make sense, that’s perfectly fine. Treating iterators as a black box until you gain a better
grasp on pointers and data structures is not such a bad thing.

\section{File I/O}

Arguably one of the more convoluted aspects of C++ is how it handles file I/O. If you’re primarily used to C,
as I am, you know that there are really only two ways of creating a file, which is either to use the FILE
struct and fopen to return a pointer to a file stream, or to use the open() system call to return a file
descriptor. In C++, akin to Java, we have much more options when it comes to handling I/O. You are already
familiar with the redirection operator (<< or >>), as it is used when we print statements to stdout using
cout. Similarly, cin reads from stdin. As you are probably aware, these are both file streams, and their C++
implementation is contained within iostream. In order to handle file streams, we need to also include the
fstream header file. This provides access to an object called ifstream. Well, technically speaking, ifstream
is a typedef for basic\_ifstream<char>. If we provide a filepath as an argument to the ifstream’s
constructor, the constructor will implicitly invoke basic\_ifstream’s implementation of open(). Alternatively,
we can simply instantiate the ifstream and then call its open() member function later, when we are ready to
actually open the file. The open() function signature is as follows: void open(const char *filename,
ios\_base::openmode mode = ios\_base::in);. Note the default argument "mode", which is set to ios\_base::in
if we do not set it manually. This parameter is actually an object of the bitmask member type openmode, which
contains the constants in, out, binary, ate, app, and trunc. The flag bits can be OR’d together e.g.,
ios\_base::in | ios\_base::binary if we wanted to read the file as a binary file instead of text. Rather than
checking if the call to open() returned nullptr or something like that (as we would do in C), we instead call
the is\_open() member function, which will return a boolean indicating whether or not the file is currently
open. At this point, there are multiple functions that we can invoke to read the contents of said file before
eventually calling close() (note that the destructor for ifstream calls close() implicitly).

The easiest way to read the contents of a file as a string is to use the redirection operator on the ifstream
object. For example:

\begin{cpplst}

#include <iostream>
#include <fstream>

int main()
{
    std::string contents;
    std::ifstream fs("todo.txt");
    if (fs.is_open())
    {
        while (fs.good())
        {
            fs >> contents;
        }
    }
    fs.close();

    std::cout << contents;
    return 0;
}

\end{cpplst}

Note the use of the good() member function. The redirection operator will read text until it encounters a
white space character or newline character, meaning that if we have multiple lines we need to use a while
loop in order to read each one. The good() member function essentially checks to see if we’ve reached the
EOF, an error occurred, or if there was a R/W error. There is also the bad() member function, which only
checks if a R/W error occurred. Alternatively, we could have just done while (fs), which is equivallent to
while (fs.good())

Similar to ftell() in C, we can use the tellg() member function (stands for tell get) to return the current
position of the file pointer as it moves through the stream. Once the entire file has been traversed, this
function returns -1.

Another way we can read files is by using the getline() member function. This is pretty much just a wrapper
around the redirection operator which returns the line that it read, not including the newline character.

I’ve also seen people use iterators to read an entire file as a string, which I have no opinion on in terms
efficiency or readability or any of that. None-the-less, it’s still good to be able to know that there are
other ways of doing the same operation. Here is an example of this:

\begin{cpplst}

std::string contents(
    std::istreambuf_iterator<char>(ifs),
    std::istreambuf_iterator<char>()
);

\end{cpplst}

What's happening here is likely not obvious to new C++ programmers. Essentially, std::string has a
constructor which accepts two parameters, both of which are iterators. Here is the definition for said
constructor:

\begin{cpplst}

template <class InputIterator>
std::string(InputIterator first, InputIterator last);

\end{cpplst}

This constructor actually just invokes the assign() member function which has  the same method signature.
What assign() does is replace the current contents of a string within the range specified by InputIterator
first and InputIterator last. Recall that std::ifstream is just a typedef for basic\_ifstream<char>, and
istreambuf\_iterator<char> is an input iterator that can read successive elements from a stream buffer. If
you look up the constructor for istreambuf\_iterator on cppreference, you’ll see that the empty constructor
constructs an end-of-stream iterator, and the constructor which accepts a std::basic\_istream initializes
the iterator and stores the value of is.rdbuf(). I know that this is perhaps starting to become confusing,
but is.rdbuf() is actually what tellg() returns (the file pointer’s position). So in other words, the empty
iterator returns and end-of-stream iterator and the non-empty one returns the current position of the file
pointer (which is pressumably 0 if we just opened the file). Then we construct a string from these two
iterators using std::string’s assign() member function!

\subsection{String Streams}

Continuing off of file streams, I wanted to also discuss string streams. String streams are kind of like
StringBuilder in Java. They allow us to construct and parse strings. To use string streams, we include the
<sstream> header. A Stringstream object can optionally accept an initial string as a constructor parameter.
Since a Stringstream is a stream, similar to an ifstream, we can use the redirection operator to append
strings or emit strings. Recall that the output redirection operator will emit up until the next whitespace
character or newline is encountered.

\section{Templates}

You may or may not have used templates in other programming langauges before. In case you have never used
templates before, I will summarize their utility. A template typically allows us to omit type information for
a given variable or function parameter so that we can polymorphically reuse code by substituting the type that
we want when the class is instantiated or function is invoked. Due to the fact that we can substitute any
type that we like by default, we refer to the placeholder value as ‘generics’. In order to create a template
in C++, we simply use the ‘template’ keyword, followed by opening and closing karats (<>), which will enclose
one of two additional keywords (I’ll demonstrate what these are in a moment), as well as the name of the
generic or generics. Assume that we have a function which adds two values called add(). Now assume that we
want to be able to have three versions of the add() function: one for ints, one for floats, and one for
doubles. Your instinct may jump to using function overloads. Overloads can become cumbersome, however, since
we must type out the same function three times with the only difference being in the types that we assign to
our parameters. This is solved with templates with the following code:

\begin{cpplst}

template <typename T>
T add(T a, T b)
{
    return a + b;
}

\end{cpplst}

When we want to invoke the add() function, we must now do so as add<T>(), where 'T' is the type that we want
to pass in to our template as the generic. Here is the full code snippet:

\begin{cpplst}

#include <iostream>

template <typename T>
T add(T a, T b)
{
    return a + b;
}

int main()
{
    double result = add<float>(2.5f, 0.9f);
    std::cout << result << std::endl;

    return 0;
}

\end{cpplst}

If you’re wondering why I’m using double for the result, it’s simply because that is the widest type for
floating point, so whether we use int, float, or double, result can store the return value. Anyhow, notice
that when we specified float as the generic, the return type as well as both parameters (a and b) became
floats. The beauty of this approach is that the compiler will generate a unique add() function at compile
time for each type variant that it is invoked with. So for instance, if I were to invoke add() twice, once
with int and once with float, it would generate two variants of the function. It is essentially doing
function overloading for us behind the scenes. The downside to templates is that we can really pass in any
type that we like as the generic and the compiler may or may not complain. For example, heres the same code,
but now I’ve changed the function arguments and type for result:

\begin{cpplst}

#include <iostream>

template <typename T>
static T add(T a, T b)
{
    return a + b;
}

int main()
{
    string result = add<string>("a", "b");
    std::cout << result << std::endl;

    return 0;
}

\end{cpplst}

As you can guess, this is still valid code, but using the add() function to concatonate strings was likely
not the programmer’s intention. In order to prevent certain types from being substituted as the generic, we
use the static\_assert() function. As you may or may not know, static\_assert(), unlike assert(), performs a
compile-time assert. Since generics are substituted at compile-time, static\_assert() can check for types
that we want to blacklist or filter out. Something clever that most people do is to use the ‘using’ statement
to create a type alias. This can be a bit confusing to follow, especially since I haven’t covered some of the
functions being used here, but I’ll throw out the example anyways:

\begin{cpplst}

#include <iostream>
#include <type_traits>

using namespace std;

template <typename T>
using _T = typename enable_if<
    is_same<int, T>::value ||
    is_same<float, T>::value ||
    is_same<double, T>::value,
    T
>::type;

template <typename T>
_T<T> add(_T<T> a, _T<T> b) {
    return a + b;
}

int main()
{
    float result = add<float>(1.0f, 1.0f);
    cout << result << endl;

    return 0;
}

\end{cpplst}

Here, \_T is an alias that only exists if T is either an int, float, or double, otherwise the type is
undefined and the compilation fails. This works due to enable\_if<T, U>::type, which I’ll let you read up on.
The type that we substitute the generic type T for when calling add<T>() will be wrapped by the
enable\_if<T, U>::type check, aliased as \_T.

I mentioned two keywords that we could use in the template declaration. The first, we’ve already seen, which
is typename. The second is the class keyword. When simply defining templates, these two keywords may be used
interchangeably. There are cases, however

\section{Type Checking Using decltype}

An easy way to return the type of a variable is through use of the decltype specifier. For example the assert
statement in the example below will succeed:

\begin{cpplst}

int a;
assert((std::is_same_v<decltype(a), int>));

\end{cpplst}

The std::is\_base\_type<Base, Derived>() function will check if the function passed in for Derived is derived
from the class passed in for Base. Under the hood this function uses a combination of the decltype keyword
and static casts (which we'll look at a bit later on).

\section{Other Useful Types (std::initializer\_list, std::optional, std::string\_view, std::filesystem::path)}

Similar to modern languages e.g. TypeScript or Rust, C++ attempts to mitigate the use of nullptr by providing
us with the std::optional<T> template. This template, introduced in C++17, allows us to wrap some data in the
std::optional type. An std::optional can either contain no data, or some data. In order to perform a check,
we can use the std::optional’s member function has\_value(), which returns true if the std::optional does
contain some data, or false otherwise. The value() member function is essentially a getter for the value if
the std::optional does contain something. Rather than tediously checking has\_value() followed by value() each
time we want to access an std::optional, we can use the value\_or() member function, which either accesses
the underlying data if it exists, or returns the value that we provide as an argument if empty. Here is a
code snippet example:

\begin{cpplst}

#include <iostream>
#include <optional>

int main()
{
    std::optional<int> opt = std::nullopt;
    std::cout << "opt: " << opt.value_or(5) << std::endl; // Prints 5
    opt = 10; // This works because std::optional overloads the assignment operator
    std::cout << "opt: " << opt.value_or(5) << std::endl; // Prints 10

    return 0;
}

\end{cpplst}

\subsection{std::initializer\_list}

By now we've seen many instances of initializer lists, but did you know that this is actually a distinct type
in C++? If you don't believe me try having your IDE display the inferred type of an auto-assigned initializer
list:

\begin{cpplst}

int main()
{
    auto arr = { 1.0f, 2.5f, 3.0f };
    static_assert(std::is_same_v<decltype(arr), decltype(std::initializer_list<float>())>);
}

\end{cpplst}

We can explicitly utilize initializer lists by including the <intializer\_list> header file. This permits us
to pass in initializer lists to functions as arguments akin to how one might utilize variable arguments.
Variable arguments generally utilize a token to mark the end of the list such as NULL. Initializer lists, on
the other hand, track the number of items internally. This lets us check the bounds using the size() member
function, and as per usual, we can iterate over an initializer list using the begin() and end() member
functions.

\section{Lambda Functions}

Lambda functions, as you are most likely aware, are short-hand, usually single-purpose/use functions that
are meant to be terse and discrete. As with most "modern" C++ features, lambdas were introduced in C++11.
C++ has a fairly distinct notation for creating lambda functions, specifically referring to the notation for
capturing variables, which I'll explain shortly. A lambda function does not really differ in any meaningful
sense from how a regular function operates, though they have slight variations, semantically speaking. Here
is what a basic lambda function may look like:

\begin{cpplst}

auto foo = [&](int x) -> int
{
    return x + 5;
}

\end{cpplst}

Some points to note here. First is that we utilize the arrow operator to denote the return type (this is
pretty common notation for most languages when it comes to lambda expressions). Another is that we can assign
a lamda expression to a variable. It's not as if we couldn't already do this with functions too, however,
C++ distinguishes between function pointers and lambdas as being their own distinct types.

As mentioned, the most peculiar aspect of lambdas in C++ is how we capture variables. And what do I mean by
that, you may ask? C++ allows us to specify the visibility of variables which are external to the lambda's
scope - specifically variables which exist in the enclosing scope of where the lambda function is defined.
We can choose between two operators: '=' and '\&'. The '=' operator indicates that we're capturing by value,
meaning we're creating a read-only copy of any variables that we capture. On the other hand, the '\&' operator
captures by reference, meaning that we can modify the underlying memory of captured variables. As shown in
the previous snippet, we can capture all variables in the enclosing scope by using either of these operators
within the square brackets. We can also, however, mix and match both capture by value and capture by reference,
as well as getting more specific with the particular variables that we capture. Take the following example:

\begin{cpplst}

int main()
{
    std::string intro = "Once upon a time";
    bool is_editable = true;

    auto f = [is_editable, &intro]() {
        if (is_editable)
        {
            intro.append(" in a galaxy far far away");
        }
    }
}

\end{cpplst}

In the example above, is\_editable is passed in by value and intro is passed in by reference. Although we can
modify the value of is\_editable within the lambda function, it works exactly like a normal function, in the
sense that this only affects the local copy and not the is\_editable from the enclosing scope. On the other
hand, when we append a string to intro, this change is applied externally.

Note our options here. We have the choice to either capture variables or the ability to pass variables in
explicitly at the call site of our lambda function. Which you choose ultimately comes down to preference,
but for the sake of anyone who may be maintaining your code, I advise you to stay consistent. Capturing
variables is, in a sense, mildly more convenient, however, passing in parameters explicitly at the call site
is a bit more readable, in my opinion. That being said, I tend to usually just capture everything by
reference and call it a day, but your milleage may vary.

\section{Exceptions}

\section{Custom Allocators/Deallocators}

\section{Synchronization}

\subsection{Promises and Futures}

\subsection{Multithreading}

If you have experience with multithreading in C, threading in C++ should feel pretty familiar to you. Of
course, given that C++ is an OOP language, the implementation for threads is a bit different. C++ does
improve upon POSIX threads by not forcing the user to follow a specific function pointer template for the
thread's routine. Recall in C that threads accepted a function pointer which had to be of type
void *(*routine)(void *args). Looking at the man page for std::thread will reveal that C++'s implementation
is a bit more convoluted:

\begin{cpplst}

template<typename _Callable, typename... _Args, typename = _Require<__not_same<_Callable>>>
thread(_Callable &&__f, _Args &&... __args)
thread (const thread &) = delete
thread (thread &&__t) noexcept

\end{cpplst}

Before I break this down, I just want to preface by reminding you that threads objects in C++, so
std::thread is both the type and constructor. As you can see, we have a templated thread class which contains
three overrides of the constructor. The latter two are both copy constructors, meaning that they just run the
same task as the thread that gets passed in as a parameter. Of course, since the second is deleted, this
inhibits us from passing in a const reference to a thread. The reason being that the thread must be mutable.
Now looking at that scary template... It’s actually not so bad; we simply take in two generics: \_Callable
and \_Args. You can probably deduce that these represent both the function/lambda/functor used by the thread
and the type of the variable argument list, respectively. The \_Require type is not actually something we pass
in, but rather a constraint specifying a certain type that \_Callable \textit{cannot} be. I am not actually
positive as to what this does, but I think it prevents passing in another thread as the callable type. Let's
now look at a typical implementation of multithreading in C++ that calculates the sum of the square root of
consecutive powers of i (of course taking the square root of a power is quite redundant, but it adds some
computational time into the mix). Here is the code:

\begin{cpplst}

#include <iostream>
#include <array>
#include <thread>
#include <mutex>
#include <cmath>

#define TPOOL_SZ 10

static float sos; // Sum of squares
static auto m = new std::mutex();

static inline void add_square(const float n)
{
    m->lock();
    sos += std::powf(n, n);
    m->unlock();
}

int main()
{
    int n = 0;
    auto threads = std::array<std::thread, TPOOL_SZ>{};

    for (auto it = threads.begin(); it != threads.end(); ++it, ++n)
    {
        threads[n] = std::thread(add_square, n);
    }

    for (auto it = threads.begin(); it != threads.end(); ++it)
    {
        it->join();
    }

    std::cout << "Sum of Squares: " << sos << std::endl;

    delete m;
    return EXIT_SUCCESS;
}

\end{cpplst}

This is pretty standard stuff as far as multithreading goes. Create a thread pool, use a synchronization
primitive like a mutex to lock on critical write segments and then block until each thread is finished using
join() before printing the result. Unfortunately, we are doing a bit of a no-no with the mutex. Reading the
man page for std::mutex tells us that we should not call lock() and unlock() directly, but instead use a
scoped lock such as std::unique\_lock, std::lock\_guard, or std::scoped\_lock. The reason that C++ advises us
to not use lock() and unlock() directly is mostly due to the fact that this ignores Resource Acquisition Is
Initialization (RAII). This is a popular idiom within C++ that proposes initialization/acquisition should
occur within the constructor of the object, and that deallocation should occur at the end of the object's
lifetime i.e., in the destructor. This is basically the entire idea behind smart pointers.

\subsection{Atomics}

An alternative to using syncronization mechanisms for basic operations in multi-threaded code is to use
atomic types and atomic operations. An atomic operation is one which occurs within one CPU cycle, meaning that
there is no chance for race conditions to occur. Atomic types only support very basic operations, such as
adding, subtracting, bitwise ORing, XORing, etc. If the type is an atomic type, C++ will implicitly perform
these operations when utilizing the standard operators, but it is heavily recommended that you invoke
the appropriate member functions explicitly.

\begin{cpplst}

#include <atomic>

int main()
{
    std::atomic<float> atom = 5;
    atom.fetch_add(5); // Same as doing += 5

    return 0;
}

\end{cpplst}

\end{document}
